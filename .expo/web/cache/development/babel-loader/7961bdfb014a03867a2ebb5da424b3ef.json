{"ast":null,"code":"import { Extrapolate } from \"../derived/interpolate\";\n\nfunction internalInterpolate(x, l, r, ll, rr, type) {\n  'worklet';\n\n  if (r - l === 0) return ll;\n  var progress = (x - l) / (r - l);\n  var val = ll + progress * (rr - ll);\n  var coef = rr >= ll ? 1 : -1;\n  type = type || Extrapolate.EXTEND;\n\n  if (coef * val < coef * ll || coef * val > coef * rr) {\n    switch (type) {\n      case Extrapolate.IDENTITY:\n        return x;\n\n      case Extrapolate.CLAMP:\n        if (coef * val < coef * ll) {\n          return ll;\n        }\n\n        return rr;\n\n      case Extrapolate.EXTEND:\n      default:\n        return val;\n    }\n  }\n\n  return val;\n}\n\nexport function interpolate(x, input, output, type) {\n  'worklet';\n\n  if (x && x.__nodeID) {\n    throw new Error('Reanimated: interpolate from V1 has been renamed to interpolateNode.');\n  }\n\n  var length = input.length;\n  var narrowedInput = [];\n\n  if (x < input[0]) {\n    narrowedInput = [input[0], input[1], output[0], output[1]];\n  } else if (x > input[length - 1]) {\n    narrowedInput = [input[length - 2], input[length - 1], output[length - 2], output[length - 1]];\n  } else {\n    for (var i = 1; i < length; ++i) {\n      if (x <= input[i]) {\n        narrowedInput = [input[i - 1], input[i], output[i - 1], output[i]];\n        break;\n      }\n    }\n  }\n\n  return internalInterpolate.apply({}, [x].concat(narrowedInput).concat(type));\n}","map":{"version":3,"sources":["C:/Users/nicov/Projects/NodeJS/valo-app/node_modules/react-native-reanimated/src/reanimated2/interpolation.js"],"names":["Extrapolate","internalInterpolate","x","l","r","ll","rr","type","progress","val","coef","EXTEND","IDENTITY","CLAMP","interpolate","input","output","__nodeID","Error","length","narrowedInput","i","apply","concat"],"mappings":"AAAA,SAASA,WAAT;;AAEA,SAASC,mBAAT,CAA6BC,CAA7B,EAAgCC,CAAhC,EAAmCC,CAAnC,EAAsCC,EAAtC,EAA0CC,EAA1C,EAA8CC,IAA9C,EAAoD;AAClD;;AACA,MAAIH,CAAC,GAAGD,CAAJ,KAAU,CAAd,EAAiB,OAAOE,EAAP;AACjB,MAAMG,QAAQ,GAAG,CAACN,CAAC,GAAGC,CAAL,KAAWC,CAAC,GAAGD,CAAf,CAAjB;AACA,MAAMM,GAAG,GAAGJ,EAAE,GAAGG,QAAQ,IAAIF,EAAE,GAAGD,EAAT,CAAzB;AACA,MAAMK,IAAI,GAAGJ,EAAE,IAAID,EAAN,GAAW,CAAX,GAAe,CAAC,CAA7B;AAIAE,EAAAA,IAAI,GAAGA,IAAI,IAAIP,WAAW,CAACW,MAA3B;;AAEA,MAAID,IAAI,GAAGD,GAAP,GAAaC,IAAI,GAAGL,EAApB,IAA0BK,IAAI,GAAGD,GAAP,GAAaC,IAAI,GAAGJ,EAAlD,EAAsD;AACpD,YAAQC,IAAR;AACE,WAAKP,WAAW,CAACY,QAAjB;AACE,eAAOV,CAAP;;AACF,WAAKF,WAAW,CAACa,KAAjB;AACE,YAAIH,IAAI,GAAGD,GAAP,GAAaC,IAAI,GAAGL,EAAxB,EAA4B;AAC1B,iBAAOA,EAAP;AACD;;AACD,eAAOC,EAAP;;AACF,WAAKN,WAAW,CAACW,MAAjB;AACA;AACE,eAAOF,GAAP;AAVJ;AAYD;;AACD,SAAOA,GAAP;AACD;;AAED,OAAO,SAASK,WAAT,CAAqBZ,CAArB,EAAwBa,KAAxB,EAA+BC,MAA/B,EAAuCT,IAAvC,EAA6C;AAClD;;AACA,MAAIL,CAAC,IAAIA,CAAC,CAACe,QAAX,EAAqB;AACnB,UAAM,IAAIC,KAAJ,CACJ,sEADI,CAAN;AAGD;;AACD,MAAMC,MAAM,GAAGJ,KAAK,CAACI,MAArB;AACA,MAAIC,aAAa,GAAG,EAApB;;AACA,MAAIlB,CAAC,GAAGa,KAAK,CAAC,CAAD,CAAb,EAAkB;AAChBK,IAAAA,aAAa,GAAG,CAACL,KAAK,CAAC,CAAD,CAAN,EAAWA,KAAK,CAAC,CAAD,CAAhB,EAAqBC,MAAM,CAAC,CAAD,CAA3B,EAAgCA,MAAM,CAAC,CAAD,CAAtC,CAAhB;AACD,GAFD,MAEO,IAAId,CAAC,GAAGa,KAAK,CAACI,MAAM,GAAG,CAAV,CAAb,EAA2B;AAChCC,IAAAA,aAAa,GAAG,CACdL,KAAK,CAACI,MAAM,GAAG,CAAV,CADS,EAEdJ,KAAK,CAACI,MAAM,GAAG,CAAV,CAFS,EAGdH,MAAM,CAACG,MAAM,GAAG,CAAV,CAHQ,EAIdH,MAAM,CAACG,MAAM,GAAG,CAAV,CAJQ,CAAhB;AAMD,GAPM,MAOA;AACL,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,MAApB,EAA4B,EAAEE,CAA9B,EAAiC;AAC/B,UAAInB,CAAC,IAAIa,KAAK,CAACM,CAAD,CAAd,EAAmB;AACjBD,QAAAA,aAAa,GAAG,CAACL,KAAK,CAACM,CAAC,GAAG,CAAL,CAAN,EAAeN,KAAK,CAACM,CAAD,CAApB,EAAyBL,MAAM,CAACK,CAAC,GAAG,CAAL,CAA/B,EAAwCL,MAAM,CAACK,CAAD,CAA9C,CAAhB;AACA;AACD;AACF;AACF;;AACD,SAAOpB,mBAAmB,CAACqB,KAApB,CAA0B,EAA1B,EAA8B,CAACpB,CAAD,EAAIqB,MAAJ,CAAWH,aAAX,EAA0BG,MAA1B,CAAiChB,IAAjC,CAA9B,CAAP;AACD","sourcesContent":["import { Extrapolate } from '../derived/interpolate';\n\nfunction internalInterpolate(x, l, r, ll, rr, type) {\n  'worklet';\n  if (r - l === 0) return ll;\n  const progress = (x - l) / (r - l);\n  const val = ll + progress * (rr - ll);\n  const coef = rr >= ll ? 1 : -1;\n\n  // TODO: support default values in worklets:\n  // e.g. function interplate(x, input, output, type = Extrapolate.CLAMP)\n  type = type || Extrapolate.EXTEND;\n\n  if (coef * val < coef * ll || coef * val > coef * rr) {\n    switch (type) {\n      case Extrapolate.IDENTITY:\n        return x;\n      case Extrapolate.CLAMP:\n        if (coef * val < coef * ll) {\n          return ll;\n        }\n        return rr;\n      case Extrapolate.EXTEND:\n      default:\n        return val;\n    }\n  }\n  return val;\n}\n\nexport function interpolate(x, input, output, type) {\n  'worklet';\n  if (x && x.__nodeID) {\n    throw new Error(\n      'Reanimated: interpolate from V1 has been renamed to interpolateNode.'\n    );\n  }\n  const length = input.length;\n  let narrowedInput = [];\n  if (x < input[0]) {\n    narrowedInput = [input[0], input[1], output[0], output[1]];\n  } else if (x > input[length - 1]) {\n    narrowedInput = [\n      input[length - 2],\n      input[length - 1],\n      output[length - 2],\n      output[length - 1],\n    ];\n  } else {\n    for (let i = 1; i < length; ++i) {\n      if (x <= input[i]) {\n        narrowedInput = [input[i - 1], input[i], output[i - 1], output[i]];\n        break;\n      }\n    }\n  }\n  return internalInterpolate.apply({}, [x].concat(narrowedInput).concat(type));\n}\n"]},"metadata":{},"sourceType":"module"}